# =============================================================================
# DOCKER COMPOSE PARA LINUX NATIVO - SIN WINDOWS
# =============================================================================
# Este archivo está optimizado para sistemas Unix/Linux nativos
# Elimina todas las dependencias y workarounds específicos de Windows

x-common-variables: &common-variables
  TZ: America/Argentina/Buenos_Aires
  APP_NAME: ${APP_NAME:-Sistema DGSUC}
  APP_ENV: ${APP_ENV:-production}
  APP_DEBUG: ${APP_DEBUG:-false}
  APP_URL: ${APP_URL:-https://dgsuc.uba.ar}
  LOG_CHANNEL: ${LOG_CHANNEL:-stack}
  LOG_LEVEL: ${LOG_LEVEL:-info}
  BROADCAST_DRIVER: ${BROADCAST_DRIVER:-log}
  CACHE_DRIVER: ${CACHE_DRIVER:-redis}
  SESSION_DRIVER: ${SESSION_DRIVER:-redis}
  SESSION_LIFETIME: ${SESSION_LIFETIME:-120}
  QUEUE_CONNECTION: ${QUEUE_CONNECTION:-redis}
  REDIS_PASSWORD: ${REDIS_PASSWORD:-redis_dev_password_456}

x-app-volumes: &app-volumes
  # Bind mounts directos - óptimos para Linux
  - ./app:/var/www/html
  - ./app/storage:/var/www/html/storage
  - ./app/bootstrap/cache:/var/www/html/bootstrap/cache

x-restart-policy: &restart-policy
  restart: unless-stopped

networks:
  dgsuc_network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.28.0.0/16

volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local
  certbot_logs:
    driver: local
  nginx_logs:
    driver: local

services:
  # PHP-FPM Application - Optimizado para Linux
  app:
    <<: *restart-policy
    env_file:
      - .env
      - .env.secrets
    build:
      context: .
      dockerfile: ./docker/app/Dockerfile
      target: ${BUILD_TARGET:-production}
    container_name: dgsuc_app
    environment:
      <<: *common-variables
      DOCKER_ENV: ${APP_ENV}
      CONTAINER_NAME: dgsuc_app
      DB_CONNECTION: pgsql
      DB_HOST: postgres
      DB_PORT: 5432
      DB_DATABASE: ${DB_DATABASE:-dgsuc_app}
      DB_USERNAME: ${DB_USERNAME:-dgsuc_user}
      DB_PASSWORD: ${DB_PASSWORD}
      DB_SCHEMA: suc_app
      
      # Database externa DB2 (otra aplicación)
      DB2_CONNECTION: ${DB2_CONNECTION:-pgsql}
      DB2_HOST: ${DB2_HOST:-postgres}
      DB2_PORT: ${DB2_PORT:-5432}
      DB2_DATABASE: ${DB2_DATABASE:-liqui}
      DB2_USERNAME: ${DB2_USERNAME:-dgsuc_user}
      DB2_PASSWORD: ${DB2_PASSWORD:-dgsuc_password_2024}
      
      # Database externa DB3 (otra aplicación)
      DB3_CONNECTION: ${DB3_CONNECTION:-pgsql}
      DB3_HOST: ${DB3_HOST:-postgres}
      DB3_PORT: ${DB3_PORT:-5432}
      DB3_DATABASE: ${DB3_DATABASE:-liqui}
      DB3_USERNAME: ${DB3_USERNAME:-dgsuc_user}
      DB3_PASSWORD: ${DB3_PASSWORD:-dgsuc_password_2024}
      
      # Variables para otras conexiones Laravel (PROD, TEST, etc.)
      DB_PROD_HOST: ${DB_PROD_HOST:-postgres}
      DB_PROD_PORT: ${DB_PROD_PORT:-5432}
      DB_PROD_DATABASE: ${DB_PROD_DATABASE:-mapuche}
      DB_PROD_USERNAME: ${DB_PROD_USERNAME:-dgsuc_user}
      DB_PROD_PASSWORD: ${DB_PROD_PASSWORD:-dgsuc_password_2024}
      
      DB_TEST_HOST: ${DB_TEST_HOST:-postgres}
      DB_TEST_PORT: ${DB_TEST_PORT:-5432}
      DB_TEST_DATABASE: ${DB_TEST_DATABASE:-sicoss_test}
      DB_TEST_USERNAME: ${DB_TEST_USERNAME:-dgsuc_user}
      DB_TEST_PASSWORD: ${DB_TEST_PASSWORD:-dgsuc_password_2024}
      
      REDIS_HOST: redis
      REDIS_PORT: 6379
      # Configuraciones específicas para Linux
      WWWUSER: ${WWWUSER:-1000}
      WWWGROUP: ${WWWGROUP:-1000}
    volumes: *app-volumes
    networks:
      - dgsuc_network
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "php-fpm", "-t"]
      interval: 30s
      timeout: 10s
      retries: 3
    # Usuario específico para Linux - evita problemas de permisos
    user: "${WWWUSER:-1000}:${WWWGROUP:-1000}"
    profiles:
      - development

  # Nginx Web Server - Configuración Linux nativa
  nginx:
    <<: *restart-policy
    build:
      context: ./docker/nginx
      dockerfile: Dockerfile
    container_name: dgsuc_nginx
    ports:
      - "${HTTP_PORT:-8080}:80"
      - "${HTTPS_PORT:-8443}:443"
    volumes:
      # Bind mounts directos para mejor performance en Linux
      - ./app:/var/www/html:ro
      - ./docker/nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./docker/nginx/sites:/etc/nginx/sites-available:ro
      - ./docker/nginx/certs:/etc/nginx/certs:ro
      - nginx_logs:/var/log/nginx
    networks:
      - dgsuc_network
    depends_on:
      app:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "nginx", "-t"]
      interval: 30s
      timeout: 10s
      retries: 3
    profiles:
      - development

  # PostgreSQL Database - Configuración optimizada para Linux
  postgres:
    <<: *restart-policy
    image: postgres:17-alpine
    container_name: dgsuc_postgres
    environment:
      POSTGRES_DB: ${DB_DATABASE:-dgsuc_app}
      POSTGRES_USER: ${DB_USERNAME:-dgsuc_user}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_INITDB_ARGS: "--encoding=UTF8 --locale=es_AR.UTF-8"
      # Configuraciones específicas para Linux
      PGUSER: ${DB_USERNAME:-dgsuc_user}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./docker/postgres/init.sql/01-create-schema.sql:/docker-entrypoint-initdb.d/01-create-schema.sql:ro
      - ./docker/postgres/init-db.sh:/docker-entrypoint-initdb.d/02-configure-auth.sh:ro
      - ./docker/postgres/postgresql.conf:/etc/postgresql/postgresql.conf:ro
    networks:
      - dgsuc_network
    ports:
      - "${DB_EXTERNAL_PORT:-5432}:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USERNAME:-dgsuc_user} -d ${DB_DATABASE:-dgsuc_app}"]
      interval: 10s
      timeout: 5s
      retries: 5
    # Configuración de memoria optimizada para Linux
    command: >
      postgres
      -c shared_buffers=256MB
      -c effective_cache_size=1GB
      -c work_mem=64MB
      -c maintenance_work_mem=128MB
      -c max_connections=100
      -c checkpoint_completion_target=0.9
      -c wal_buffers=16MB
      -c log_statement=mod
      -c log_min_duration_statement=1000
    profiles:
      - development

  # Redis Cache - Configuración Linux nativa
  redis:
    <<: *restart-policy
    image: redis:7-alpine
    container_name: dgsuc_redis
    environment:
      - REDIS_PASSWORD=${REDIS_PASSWORD}
    volumes:
      - redis_data:/data
    networks:
      - dgsuc_network
    ports:
      - "${REDIS_EXTERNAL_PORT:-6379}:6379"
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}

    healthcheck:
      test: ["CMD-SHELL", "redis-cli -a ${REDIS_PASSWORD} ping | grep PONG"]
      interval: 10s
      timeout: 5s
      retries: 3
    profiles:
      - development

  # Queue Workers - Sin supervisord, usando init nativo de Linux
  workers:
    <<: *restart-policy
    env_file:
      - .env
      - .env.secrets
    build:
      context: ./docker/workers
      dockerfile: Dockerfile
    container_name: dgsuc_workers
    environment:
      <<: *common-variables
      WORKER_PROCESSES: ${WORKER_PROCESSES:-2}
      WORKER_MEMORY: ${WORKER_MEMORY:-1024}
      WORKER_TIMEOUT: ${WORKER_TIMEOUT:-3600}
      DB_CONNECTION: pgsql
      DB_HOST: postgres
      DB_PORT: 5432
      DB_DATABASE: ${DB_DATABASE:-dgsuc_app}
      DB_USERNAME: ${DB_USERNAME:-dgsuc_user}
      DB_PASSWORD: ${DB_PASSWORD}
      DB_SCHEMA: suc_app
      REDIS_HOST: redis
      REDIS_PORT: 6379
      REDIS_PASSWORD: ${REDIS_PASSWORD}
    volumes: *app-volumes
    networks:
      - dgsuc_network
    depends_on:
      app:
        condition: service_healthy
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    # Comando simplificado para Linux
    command: php /var/www/html/artisan queue:work --sleep=3 --tries=3 --max-time=3600
    profiles:
      - development

  # Scheduler - Cron nativo de Linux
  scheduler:
    <<: *restart-policy
    build:
      context: .
      dockerfile: ./docker/app/Dockerfile
      target: ${BUILD_TARGET:-production}
    container_name: dgsuc_scheduler
    environment:
      <<: *common-variables
    volumes: *app-volumes
    networks:
      - dgsuc_network
    depends_on:
      app:
        condition: service_healthy
    # Cron simplificado para Linux
    command: >
      sh -c "
      while true; do
        php /var/www/html/artisan schedule:run --verbose --no-interaction
        sleep 60
      done"

  # Certbot SSL - Configuración Linux nativa
  certbot:
    image: certbot/certbot:latest
    container_name: dgsuc_certbot
    volumes:
      - ./docker/nginx/certs:/etc/letsencrypt
      - ./app/public:/var/www/html
      - certbot_logs:/var/log/letsencrypt
    environment:
      - CERTBOT_EMAIL=${CERTBOT_EMAIL:-admin@uba.ar}
      - CERTBOT_DOMAIN=${CERTBOT_DOMAIN:-dgsuc.uba.ar}
    command: >
      sh -c "
      certbot certonly --webroot --webroot-path=/var/www/html
      --email $${CERTBOT_EMAIL} --agree-tos --no-eff-email
      -d $${CERTBOT_DOMAIN} -d www.$${CERTBOT_DOMAIN}
      --keep-until-expiring --non-interactive
      "
    depends_on:
      nginx:
        condition: service_healthy
    restart: "no"
    profiles:
      - ssl